#!/bin/sh
#|-*- mode:lisp -*-|#
#|
exec ros -Q -- $0 "$@"
|#

(progn ;;init forms
  (ros:ensure-asdf)
  #+quicklisp(ql:quickload '("str" "split-sequence") :silent t)
  )


(defpackage :ros.script.beer-me.3954356029
  (:use :cl))
(in-package :ros.script.beer-me.3954356029)

(defun replace-all (string part replacement &key (test #'char=))
  "Returns a new string in which all the occurences of the part
is replaced with replacement."
  (with-output-to-string (out)
    (loop with part-length = (length part)
          for old-pos = 0 then (+ pos part-length)
          for pos = (search part string
                            :start2 old-pos
                            :test test)
          do (write-string string out
                           :start old-pos
                           :end (or pos (length string)))
          when pos do (write-string replacement out)
            while pos)))

(defparameter *environments* nil)
(defparameter *config-dir* (uiop:native-namestring "~/.config/beer-me/"))
(defparameter *env-file* (uiop:native-namestring
                          (concatenate 'string
                                       *config-dir*
                                       ".envlist")))

(defun setup-default-queries ()
  (ensure-directories-exist *config-dir*)
  (unless (probe-file *env-file*)
    (with-open-file (f *env-file* :direction :output
                                  :if-does-not-exist :create)
      (write-sequence "DEFAULT \"psql -h localhost -d database -U postgres -p 5432\"" f))))


(defun get-filters (filter-list)
  (let ((filter-pairs (loop :for filter :on filter-list :by #'cddr
                            :collect (cons (car filter) (cadr filter)))))
    (if (= 0 (length filter-pairs))
        ""
        (format nil "WHERE~{ ~A~^ AND~&     ~}"
                (loop :for filter-pair :in filter-pairs
                      :collect (format nil "~A = ~A"
                                       (car filter-pair)
                                       (cdr filter-pair)))))))

(defun print-usage (&optional ctx)
  (declare (ignorable ctx))
  (format t "USAGE: beer-me [environment] <resource> [filters]"))

(define-condition missing-template (error) ())
(defun get-query (query-type)
  (let ((filename (uiop:native-namestring
                   (concatenate 'string
                                "~/.config/beer-me/"
                                query-type
                                ".sql"))))
    (if (probe-file filename)
        (uiop:read-file-string filename)
        (error 'missing-template
               :message (format t "Missing template file for ~A: ~A~%" query-type filename)))))

(defun run-query (env-pair query-type filters)
  (if env-pair                                                        ; if we have a valid environment
      (uiop:run-program                                               ; run the psql command for that environment
       (str:collapse-whitespaces                                      ; removing extraneous whitespace
        (concatenate 'string (cdr env-pair) " -c \""                  ; passing a command
                     (replace-all (get-query query-type) "\"" "\\\"") ; consisting of the query for the resource (with quotes escaped)
                     filters ";\"")))                                 ; followed by the statement-ending semicolon
      ;; ELSE
      (format t "[[ QUERY ]]~A~%"      ; simply output the query, without compacting
              (concatenate 'string
                           (get-query query-type)
                           filters
                           ";"))))

(defun get-environments ()
  (loop :for env-pair-string :in (str:lines (str:from-file *env-file*))
        :collect (let ((env-name-pair-list (str:split " " env-pair-string :limit 2)))
                   (cons (read-from-string (car env-name-pair-list))
                         (cadr env-name-pair-list)))))

(defun get-args (argv)
  (let ((env (assoc (read-from-string (car argv)) *environments*)))
    (format t "env: ~A~%read: ~A~%args: ~A~%envs: ~A~%" env (read-from-string (car argv)) argv *environments*)
    (if env
        (values env (cadr argv) (get-filters (cddr argv)))
        (values nil (car argv) (get-filters (cdr argv))))))

(defun main (&rest argv)
  (declare (ignorable argv))
  (if (= (length argv) 0)
      (print-usage)
      (handler-bind ((error #'print-usage))
        (setq *environments* (get-environments))
        (multiple-value-bind (env-pair query-type filters) (get-args argv)
          (setup-default-queries)
          (run-query env-pair query-type filters)))))

;;; vim: set ft=lisp lisp:
